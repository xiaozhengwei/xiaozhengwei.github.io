# JVM



##  什么是GCRoots,哪些可以作为GCRoots对象

**一、可达性分析算法：**通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。

  在java语言中，可作为GCRoot的对象包括以下几种：

  **a.** java虚拟机栈(栈帧中的本地变量表)中的引用的对象。 

  **b**.方法区中的类静态属性引用的对象。 

  **c**.方法区中的常量引用的对象。 

  **d**.本地方法栈中JNI本地方法的引用对象。

**二、GC(Garbage Collector) Roots** 实际上是垃圾回收器需要回收的对象。垃圾回收器回收那些不是 GC Roots 的对象并且不再被GC Roots引用的对象。

这里有几种可以作为 GC Roots 的对象。一个对象可以属于多种类型的 Root。有以下几种类型的 Root 对象。

Class-通过系统的类加载器加载的class。这种class是不可能被卸载的。它们可以通过静态数据域引用对象。这里需要注意的是，通过用户自定义的类加载器加载的Class并不能作为 GC Roots，除非相应的 java.lang.Class 的实例恰巧成为 GC Roots 对象。

Thrad-存活的线程

Stack LocalJava 方法中的变量或者方法形参

JNI Local-JNI方法中的变量或者方法形参

JNI Global-全局 JNI引用

Monitor Used-用于同步监控的对象

Held by JVM-JVM由于一些原因会从垃圾回收器中持有一些对象的引用。实际上，这里和 JVM本身的实现有关。一些可能的已知原因是，系统的类加载器，一些jvm自身已知的异常类，一些预分配的异常处理对象，正在加载类的自定义类加载器。很不爽的是，JVM基本没有提供额外的细节去描述这些对象。因此，这仅仅能通过分析去判断哪些对象是所谓的 JVM持有的。

如果一个对象是一个 GC Roots 对象，在所有的视图中它都会被特别的标记来表明它是一个独立的对象。下面这张图展示了一个 Fragment 中的对象视图路径



## Hotspot JVM 后台运行的系统线程主要有下面几个：

- 虚拟机线程（VM thread）: 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有: stop-theworld、垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。
- 周期性任务线程 : 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。
- GC 线程 : 这些线程支持 JVM 中不同的垃圾回收活动。
- 编译器线程 : 这些线程在运行时将字节码动态编译成本地平台相关的机器码。
- 信号分发线程 : 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。



## 