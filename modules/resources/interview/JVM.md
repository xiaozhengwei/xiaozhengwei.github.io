# JVM



##  什么是GCRoots,哪些可以作为GCRoots对象

**一、可达性分析算法：**通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。

  在java语言中，可作为GCRoot的对象包括以下几种：

  **a.** java虚拟机栈(栈帧中的本地变量表)中的引用的对象。 

  **b**.方法区中的类静态属性引用的对象。 

  **c**.方法区中的常量引用的对象。 

  **d**.本地方法栈中JNI本地方法的引用对象。

**二、GC(Garbage Collector) Roots** 实际上是垃圾回收器需要回收的对象。垃圾回收器回收那些不是 GC Roots 的对象并且不再被GC Roots引用的对象。

这里有几种可以作为 GC Roots 的对象。一个对象可以属于多种类型的 Root。有以下几种类型的 Root 对象。

Class-通过系统的类加载器加载的class。这种class是不可能被卸载的。它们可以通过静态数据域引用对象。这里需要注意的是，通过用户自定义的类加载器加载的Class并不能作为 GC Roots，除非相应的 java.lang.Class 的实例恰巧成为 GC Roots 对象。

Thrad-存活的线程

Stack LocalJava 方法中的变量或者方法形参

JNI Local-JNI方法中的变量或者方法形参

JNI Global-全局 JNI引用

Monitor Used-用于同步监控的对象

Held by JVM-JVM由于一些原因会从垃圾回收器中持有一些对象的引用。实际上，这里和 JVM本身的实现有关。一些可能的已知原因是，系统的类加载器，一些jvm自身已知的异常类，一些预分配的异常处理对象，正在加载类的自定义类加载器。很不爽的是，JVM基本没有提供额外的细节去描述这些对象。因此，这仅仅能通过分析去判断哪些对象是所谓的 JVM持有的。

如果一个对象是一个 GC Roots 对象，在所有的视图中它都会被特别的标记来表明它是一个独立的对象。下面这张图展示了一个 Fragment 中的对象视图路径